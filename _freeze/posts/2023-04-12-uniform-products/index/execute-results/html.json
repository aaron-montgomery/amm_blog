{
  "hash": "9a7230581e7fc096a783743bb3c9021c",
  "result": {
    "markdown": "---\ntitle: \"Uniform Products: Problem\"\nformat:\n  html:\n    fig-width: 9\n    fig-height: 6\n    fig-align: 'center'\ndescription: \"A pocket-sized probability puzzle\"\nauthor: \"Aaron Montgomery\"\ndate: \"2023-04-12\"\ncategories: [counterintuitive, python-language]\nimage: \"mika-baumeister-Wpnoqo2plFA-unsplash.jpg\"\n---\n\n| ![](mika-baumeister-Wpnoqo2plFA-unsplash.jpg) |\n|:--:|\n| <font size = \"2\"> Photo by <a href=\"https://unsplash.com/@mbaumi?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Mika Baumeister</a> on <a href=\"https://unsplash.com/photos/Wpnoqo2plFA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a> </font>|\n\n# Uniformly-distributed numbers\n\nLet's start with a refresher of uniform numbers: numbers that are uniformly-\ndistributed on an interval $[a, b]$ can assume any decimal value in that range\nwithout preference to any particular subinterval. They're the usual thing people\nmean when they talk about \"random numbers\". Here's a bit of Python code to \ngenerate five independent uniformly-distributed numbers on $[0, 1]$:[^1] \n\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n# establish random number generator with seed for reproducibility\nrng = np.random.default_rng(seed=6538)\n\nprint(rng.uniform(low=0, high=1, size=5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.79730922 0.18164333 0.11063476 0.81771383 0.18290457]\n```\n:::\n:::\n\n\nAnd here's a visualization of ten thousand uniformly-distributed numbers \ngenerated on $[0, 1]$:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show code\"}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.hist(rng.uniform(low=0, high=1, size=10000),\n        bins=10,\n        edgecolor='black'\n        )\nax.set_title('10K random numbers uniformly distributed on [0,1]')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=732 height=496}\n:::\n:::\n\n\nAll bars have roughly equal heights with no discernible trends. Now, let's ask\nan interesting question: **What happens if we multiply all these numbers\ntogether?**\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(rng.uniform(low=0, high=1, size=10000).prod())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0\n```\n:::\n:::\n\n\nOkay, I lied; that's not interesting at all. Since all those numbers are less\nthan 1, every time we throw a new one into the product, the product will just\nget smaller. The end result will be something positive, but computationally\nindistinguishable from 0. Let's watch this in action by graphing how the \nproducts evolve after just a few terms:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show code\"}\n# length of sample path, i.e. number of uniformly-distributed numbers within\n# each product group\nn = 15\n\n# generate ten sample paths of random walk, organized in columns\nuniform_nums = rng.uniform(low=0, high=1, size=10*n).reshape([n, 10])\n\n# find the cumulative products within columns, starting from the top;\n# the kth element in a given column is the product of the k numbers that lie on \n# or above it\nsample_path = uniform_nums.cumprod(axis = 0)\n\nfig, ax = plt.subplots()\n\n# plot each of the columns as separate paths\nfor i in range(10):\n    ax.plot(np.linspace(1,n,n), sample_path[:, i], alpha=0.5)\n\nax.set_title('Cumulative Products: Random Numbers on [0, 1]')\nax.set_xlabel('Number of terms in product')\nax.set_ylabel('Product')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=738 height=515}\n:::\n:::\n\n\nThis is a visualization of ten different 'runs' of products, each of which \nconsists of multiplying fifteen numbers uniformly drawn on $[0, 1]$. As\nexpected, the products collapse to 0 almost immediately.\n\n---\n\nSo, what if we make the numbers bigger? Instead of restricting them to $[0, 1]$,\nlet's spread them out a bit and consider numbers uniformly distributed on\n$[0, 10]$. This time, about $10\\%$ of the numbers will be less than 1 (and\nthereby make the product smaller), but the other $90\\%$ of the numbers will be\nbetween 1 and 9 (and thereby make the product bigger). Maybe that will be\nenough....?\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nprint(rng.uniform(low=0, high=10, size=10000).prod())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninf\n```\n:::\n:::\n\n\nYep! This time, we get a huge number that Python can't distinguish from\ninfinity. Let's visualize this like before:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Show code\"}\n# length of sample path, i.e. number of uniformly-distributed numbers within\n# each product group\nn = 15\n\n# generate ten sample paths of random walk, organized in columns\nuniform_nums = rng.uniform(low=0, high=10, size=10*n).reshape([n, 10])\n\n# find the cumulative products within columns, starting from the top;\n# the kth element in a given column is the product of the k numbers that lie on \n# or above it\nsample_path = uniform_nums.cumprod(axis = 0)\n\nfig, ax = plt.subplots()\n\n# plot each of the columns as separate paths\nfor i in range(10):\n    ax.plot(np.linspace(1,n,n), sample_path[:, i], alpha=0.5)\n\nax.set_title('Cumulative Products: Random Numbers on [0, 10]')\nax.set_xlabel('Number of terms in product')\nax.set_ylabel('Product')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=725 height=515}\n:::\n:::\n\n\nLooking carefully at the y-axis shows that after just fifteen terms, a few of\nour products became very large; the largest of the ten trials in the graph above\nis about 6 billion, and five of the ten trials were over 1 billion. When we \ncombine this with our previous exploration involving ten thousand terms, a\npicture starts to emerge: these products get huge.\n\n---\n\nSo, to recap: we've computed a product of many numbers generated uniformly on \n$[0, C]$ with two different values of $C$.\n\n  * When $C = 1$, the product collapsed down to $0$.\n  * When $C = 10$, the product exploded toward infinity.\n  \nNow, we *actually* have an interesting question... **Where is the cutoff**?\nThat is, for what value of $C$ does the product switch from being very small to\nbeing very large?\n\n# The Incorrect Answer\n\nOne reasonable first guess is that something interesting might happen when \n$C = 2$. If our numbers come from $[0, 2]$, then half of them will make the\ncumulative product bigger, and half of them would make it smaller.\n\nBut....\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nrng.uniform(low=0, high=2, size=10000).prod()\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n0.0\n```\n:::\n:::\n\n\nAnd just to make sure that $2$ is not right on the boundary of some change in\nbehavior....\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nrng.uniform(low=0, high=2.1, size=10000).prod()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n0.0\n```\n:::\n:::\n\n\nSo, the change of behavior doesn't come at $C = 2$; evidently, it's something\nhigher than $2$ (and lower than $10$).\n\n# The Correct Answer\n\nBefore I reveal the correct answer, I want to point out that **you**, the\nreader, can play around with this yourself! If you have a place to run some\nPython code, here's a snippet to get started:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfrom numpy.random import default_rng\nrng = default_rng()\nprint(rng.uniform(low=0, high=10, size=n).prod())\n```\n:::\n\n\nIf you don't have a place to run Python code, I can provide one! Here's a \n[Google Colab notebook](https://colab.research.google.com/drive/1b40ZqoKZuXeblvGGwSe68f25B5XxliCx?usp=sharing)\nthat you can open and run right away; no setup or Python installation required \non your local machine at all.\n\nEven if you're completely unfamiliar with programming, you can play with the \nColab notebook above and partake in this experiment. When you're ready to see\nthe answer, it's \n[here](https://aaron-montgomery.github.io/amm_blog/posts/2023-04-11-uniform-products-solution/).\n\n[^1]: Technically, these are [pseudorandom numbers](https://en.wikipedia.org/wiki/Pseudorandomness); von Neumann might accuse me of living in a [state of sin](https://en.wikiquote.org/wiki/John_von_Neumann) if I conflate the two. They're also just floating-point approximations of real numbers, not the genuine article. That's all okay; the magic will happen anyway despite these indiscretions.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}